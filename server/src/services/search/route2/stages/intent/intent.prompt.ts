/**
 * INTENT Stage Prompt
 * Router-only prompt for search mode classification
 */

import { createHash } from 'crypto';

export const INTENT_PROMPT_VERSION = 'intent_v8';

export const INTENT_SYSTEM_PROMPT = `Route classifier for restaurant search. JSON only.

INPUT: { userQuery, gateAssistantLanguage, hasUserLocation }

RULES:
1) route:
   - NEARBY only if intent is “near me / around me / nearby” AND NOT “near <named place>”
   - LANDMARK only if query is “near <specific place>” (POI / street / mall / landmark), NOT a city/area
   - TEXTSEARCH if query contains a city/area/region (e.g., “בגדרה/ת״א/אשקלון”) or any explicit area text
   - default TEXTSEARCH

2) assistantLanguage: copy gateAssistantLanguage (never detect)

3) regionCode (REQUIRED, nullable):
   - Infer geographic region/country from query semantics (NOT device location)
   - If query mentions a well-known city/landmark that implies a country, output ISO-3166-1 alpha-2 code
   - Examples:
     * "Рестораны рядом с Big Ben" → regionCode="GB" (Big Ben is in London, UK)
     * "מסעדות ליד מגדל אייפל" → regionCode="FR" (Eiffel Tower is in Paris, France)
     * "pizza near Colosseum" → regionCode="IT" (Colosseum is in Rome, Italy)
     * "sushi near Times Square" → regionCode="US" (Times Square is in New York, USA)
     * "מסעדות לידי" → regionCode=null (no geographic clue, use device fallback)
     * "pizza in Tel Aviv" → regionCode="IL" (Tel Aviv is in Israel)
   - If query has NO geographic clues (city/landmark/country), set regionCode=null
   - ONLY use well-known landmarks/cities with high confidence
   - DO NOT guess or use device location - be conservative

4) clarify (REQUIRED):
   - if route=NEARBY and hasUserLocation=false:
     { 
       reason: "MISSING_LOCATION",
       blocksSearch: true,
       suggestedAction: "ASK_LOCATION",
       message: "To search 'near me', I need your location. Please enable location or specify an area (e.g., 'pizza in Tel Aviv').",
       question: "Which area are you searching in?"
     }
     (Translate message/question to gateAssistantLanguage: he/ar/ru/fr/es)
   - else null

LANGUAGE EXAMPLES:
- he: message="כדי לחפש 'לידי' אני צריך את המיקום שלך. אפשר לאשר מיקום או לכתוב עיר/אזור (למשל: 'פיצה בגדרה').", question="באיזה אזור אתה מחפש?"
- ar: message="للبحث 'بالقرب مني'، أحتاج إلى موقعك. يرجى تمكين الموقع أو تحديد منطقة (مثل: 'بيتزا في تل أبيب').", question="في أي منطقة تبحث؟"
- ru: message="Чтобы искать 'рядом со мной', мне нужно ваше местоположение. Пожалуйста, включите геолокацию или укажите район (например: 'пицца в Тель-Авиве').", question="В каком районе вы ищете?"
- fr: message="Pour rechercher 'près de moi', j'ai besoin de votre position. Veuillez activer la localisation ou spécifier une zone (par exemple : 'pizza à Tel Aviv').", question="Dans quelle zone cherchez-vous ?"
- es: message="Para buscar 'cerca de mí', necesito tu ubicación. Por favor, activa la ubicación o especifica un área (por ejemplo: 'pizza en Tel Aviv').", question="¿En qué área estás buscando?"


`;


/**
 * Manually define the JSON Schema to avoid circular dependency issues 
 * between the prompt and the Zod types during runtime.
 */
export const INTENT_JSON_SCHEMA = {
   type: "object",
   properties: {
      route: { type: "string", enum: ["TEXTSEARCH", "NEARBY", "LANDMARK"] },
      confidence: { type: "number", minimum: 0, maximum: 1 },
      reason: { type: "string", minLength: 1 },
      language: { type: "string", enum: ["he", "en", "ru", "ar", "fr", "es", "other"] },
      languageConfidence: { type: "number", minimum: 0, maximum: 1 },
      regionCandidate: { type: "string", pattern: "^[A-Z]{2}$" },
      regionConfidence: { type: "number", minimum: 0, maximum: 1 },
      regionReason: { type: "string", minLength: 1 },
      regionCode: { type: ["string", "null"], pattern: "^[A-Z]{2}$" },
      cityText: { type: ["string", "null"], minLength: 1 },
      assistantLanguage: { type: "string", enum: ["he", "en", "ru", "ar", "fr", "es"] },

      // Hybrid ordering intent flags
      distanceIntent: { type: "boolean" },
      openNowRequested: { type: "boolean" },
      priceIntent: { type: "string", enum: ["cheap", "any"] },
      qualityIntent: { type: "boolean" },
      occasion: { type: ["string", "null"], enum: ["romantic", null] },
      cuisineKey: { type: ["string", "null"] },

      // CLARIFY Payload (required, nullable)
      // NEW v7: message/question generated by Intent LLM in assistantLanguage
      clarify: {
         type: ["object", "null"],
         properties: {
            reason: { type: "string", enum: ["MISSING_LOCATION", "MISSING_FOOD", "AMBIGUOUS"] },
            blocksSearch: { type: "boolean", const: true },
            suggestedAction: { type: "string", enum: ["ASK_LOCATION", "ASK_FOOD", "REFINE"] },
            message: { type: "string", minLength: 1 },
            question: { type: "string", minLength: 1 }
         },
         required: ["reason", "blocksSearch", "suggestedAction", "message", "question"],
         additionalProperties: false
      }
   },
   required: [
      "route",
      "confidence",
      "reason",
      "language",
      "languageConfidence",
      "regionCandidate",
      "regionConfidence",
      "regionReason",
      "regionCode",
      "cityText",
      "assistantLanguage",
      "distanceIntent",
      "openNowRequested",
      "priceIntent",
      "qualityIntent",
      "occasion",
      "cuisineKey",
      "clarify"
   ],
   additionalProperties: false
};


/**
 * Generate a hash for the schema to manage versioning and caching.
 */
export const INTENT_SCHEMA_HASH = createHash('sha256')
   .update(JSON.stringify(INTENT_JSON_SCHEMA))
   .digest('hex')
   .substring(0, 12);

/**
 * Generate a hash for the system prompt to track changes.
 */
export const INTENT_PROMPT_HASH = createHash('sha256')
   .update(INTENT_SYSTEM_PROMPT, 'utf8')
   .digest('hex');
