/**
 * INTENT Stage - ROUTE2 Pipeline
 * 
 * Router-only LLM stage - no extraction
 * Determines search mode: TEXTSEARCH/NEARBY/LANDMARK
 * 
 * Target: <1500ms with timeout enforcement
 */

import type { SearchRequest } from '../../../types/search-request.dto.js';
import type { Route2Context, IntentResult } from '../../types.js';
import type { Message } from '../../../../../llm/types.js';
import { logger } from '../../../../../lib/logger/structured-logger.js';
import { resolveLLM } from '../../../../../lib/llm/index.js';
import { IntentLLMSchema } from './intent.types.js';
import {
  INTENT_SYSTEM_PROMPT,
  INTENT_JSON_SCHEMA,
  INTENT_SCHEMA_HASH,
  INTENT_PROMPT_VERSION,
  INTENT_PROMPT_HASH
} from './intent.prompt.js';
import { startStage, endStage } from '../../../../../lib/telemetry/stage-timer.js';
import { sanitizeQuery } from '../../../../../lib/telemetry/query-sanitizer.js';
import { isValidRegionCode } from '../../utils/region-code-validator.js';

/**
 * Create fallback result when LLM fails
 * Conservative fallback: TEXTSEARCH with low confidence
 */
function isAbortTimeoutError(err: unknown): boolean {
  const msg = err instanceof Error ? err.message : String(err);
  return msg.toLowerCase().includes('abort') || msg.toLowerCase().includes('timeout');
}

function resolveFallbackLanguage(query: string): 'he' | 'en' {
  return /[\u0590-\u05FF]/.test(query) ? 'he' : 'en';
}

function createFallbackResult(query: string, isTimeout: boolean): IntentResult {
  const fallbackLanguage = resolveFallbackLanguage(query);
  return {
    route: 'TEXTSEARCH',
    confidence: 0.3,
    reason: isTimeout ? 'fallback_timeout' : 'fallback',
    language: fallbackLanguage,
    languageConfidence: 0.5, // Moderate confidence for fallback
    assistantLanguage: fallbackLanguage as 'he' | 'en', // Normalize to assistant language
    regionCandidate: 'IL',
    regionConfidence: 0.1,
    regionReason: 'fallback_default',
    clarify: null, // Not clarifying in fallback
    // NEW: Default hybrid ordering flags for fallback
    distanceIntent: false,
    openNowRequested: false,
    priceIntent: 'any',
    qualityIntent: false,
    occasion: null,
    cuisineKey: null
  };
}


/**
 * Execute INTENT stage with retry on timeout
 * 
 * @param request Search request
 * @param context Pipeline context
 * @returns Intent routing decision
 */
export async function executeIntentStage(
  request: SearchRequest,
  context: Route2Context
): Promise<IntentResult> {
  const { requestId, traceId, sessionId, llmProvider, userLocation, langCtx } = context;
  const { queryLen, queryHash } = sanitizeQuery(request.query);

  const startTime = startStage(context, 'intent', {
    queryLen,
    queryHash
  });

  // Extract Gate language context (required for Intent)
  const gateAssistantLanguage = langCtx?.assistantLanguage || resolveFallbackLanguage(request.query);
  const gateAssistantLanguageConfidence = langCtx?.assistantLanguageConfidence || 0.5;
  const uiLanguageHint = langCtx?.uiLanguage || null;

  try {
    // Resolve model and timeout for intent purpose
    const { model, timeoutMs } = resolveLLM('intent');

    // Build structured JSON input (explicit Gate context)
    const userMessage = JSON.stringify({
      userQuery: request.query,
      gateAssistantLanguage,
      gateAssistantLanguageConfidence,
      uiLanguageHint
    });

    const messages: Message[] = [
      { role: 'system', content: INTENT_SYSTEM_PROMPT },
      { role: 'user', content: userMessage }
    ];

    // Single attempt (llmProvider handles retries with maxAttempts=3)
    const response = await llmProvider.completeJSON(
      messages,
      IntentLLMSchema,
      {
        model,
        temperature: 0.1,
        timeout: timeoutMs,
        requestId,
        ...(traceId && { traceId }),
        ...(sessionId && { sessionId }),
        stage: 'intent',
        promptVersion: INTENT_PROMPT_VERSION,
        promptHash: INTENT_PROMPT_HASH,
        schemaHash: INTENT_SCHEMA_HASH
      },
      INTENT_JSON_SCHEMA
    );

    if (!response || !response.data) {
      logger.warn({
        requestId,
        pipelineVersion: 'route2',
        stage: 'intent',
        event: 'intent_schema_invalid',
        schemaName: 'IntentLLMSchema',
        schemaVersion: INTENT_PROMPT_VERSION,
        schemaHash: INTENT_SCHEMA_HASH,
        rootTypeDetected: typeof response?.data,
        intentFailed: true,
        reason: 'fallback_schema_invalid',
        msg: '[ROUTE2] Intent LLM returned invalid/empty response'
      });
      endStage(context, 'intent', startTime, { intentFailed: true, reason: 'fallback_schema_invalid' });
      const fallbackResult = createFallbackResult(request.query, false);
      // Inject Gate language into fallback
      fallbackResult.assistantLanguage = gateAssistantLanguage as 'he' | 'en' | 'ru' | 'ar' | 'fr' | 'es';
      return fallbackResult;
    }

    const llmResult = response.data;

    // CLARIFY injection: If NEARBY without userLocation, ensure clarify is set
    if (llmResult.route === 'NEARBY' && !userLocation) {
      if (!llmResult.clarify) {
        // LLM failed to provide clarify - inject deterministic fallback
        logger.warn({
          requestId,
          pipelineVersion: 'route2',
          stage: 'intent',
          event: 'nearby_missing_location_clarify_injected',
          assistantLanguage: gateAssistantLanguage
        }, '[ROUTE2] NEARBY without location - injecting clarify fallback');

        const clarifyMessages: Record<string, { message: string; question: string }> = {
          he: { message: 'כדי לחפש מסעדות קרובות אני צריך את המיקום שלך.', question: 'באיזו עיר אתה נמצא (או תשתף מיקום)?' },
          en: { message: 'I need your location to find places near you.', question: 'What city are you in (or can you share location)?' },
          ar: { message: 'أحتاج موقעך للعثור على أماكن قريبة منך.', question: 'في أي مدينة أنت (أو يمكنك مشاركة الموقع)?' },
          ru: { message: 'Мне нужно ваше местоположение.', question: 'В каком городе вы находитесь?' },
          fr: { message: 'J\'ai besoin de votre position.', question: 'Dans quelle ville êtes-vous?' },
          es: { message: 'Necesito tu ubicación.', question: '¿En qué ciudad estás?' }
        };
        const fallback = clarifyMessages[gateAssistantLanguage] || clarifyMessages['en'];
        
        // NOTE: message/question will be generated deterministically at publish time
        llmResult.clarify = {
          reason: 'MISSING_LOCATION',
          blocksSearch: true,
          suggestedAction: 'ASK_LOCATION'
        };
      }
    }
    // Validate regionCandidate against ISO-3166-1 allowlist
    // If invalid (e.g., "TQ", "IS"), set to null to trigger device/default fallback
    // This prevents noise in logs and downstream sanitization events
    const validatedRegionCandidate = isValidRegionCode(llmResult.regionCandidate)
      ? llmResult.regionCandidate
      : null; // Invalid codes trigger fallback to device region or default

    if (llmResult.regionCandidate !== validatedRegionCandidate) {
      logger.debug({
        requestId,
        pipelineVersion: 'route2',
        stage: 'intent',
        event: 'region_candidate_rejected',
        rejected: llmResult.regionCandidate,
        reason: 'invalid_iso_code'
      }, '[ROUTE2] Intent regionCandidate rejected (invalid ISO code)');
    }

    endStage(context, 'intent', startTime, {
      route: llmResult.route,
      confidence: llmResult.confidence,
      reason: llmResult.reason
    });

    // Normalize null to undefined for cityText
    const cityText = llmResult.cityText ?? undefined;

    return {
      route: llmResult.route,
      confidence: llmResult.confidence,
      reason: llmResult.reason,
      language: llmResult.language,
      languageConfidence: llmResult.languageConfidence,
      assistantLanguage: gateAssistantLanguage as 'he' | 'en' | 'ru' | 'ar' | 'fr' | 'es', // From Gate, NOT from LLM
      regionCandidate: validatedRegionCandidate,
      regionConfidence: llmResult.regionConfidence,
      regionReason: llmResult.regionReason,
      ...(cityText && { cityText }),
      clarify: llmResult.clarify, // null or object
      // Hybrid ordering intent flags
      distanceIntent: llmResult.distanceIntent,
      openNowRequested: llmResult.openNowRequested,
      priceIntent: llmResult.priceIntent,
      qualityIntent: llmResult.qualityIntent,
      occasion: llmResult.occasion,
      cuisineKey: llmResult.cuisineKey
    };

  } catch (error) {
    const isTimeout = isAbortTimeoutError(error);
    const errorMsg = error instanceof Error ? error.message : 'unknown';

    logger.warn({
      requestId,
      pipelineVersion: 'route2',
      stage: 'intent',
      event: 'intent_error_caught',
      error: errorMsg,
      isTimeout,
      intentFailed: true,
      reason: isTimeout ? 'fallback_timeout' : 'fallback_error',
      msg: '[ROUTE2] Intent LLM error - falling back to TEXTSEARCH'
    });

    endStage(context, 'intent', startTime, {
      error: errorMsg,
      isTimeout,
      intentFailed: true,
      reason: isTimeout ? 'fallback_timeout' : 'fallback_error'
    });

    // Return deterministic fallback (no unhandled rejections)
    const fallbackResult = createFallbackResult(request.query, isTimeout);
    // Inject Gate language if available (filter out 'other')
    if (langCtx?.assistantLanguage && langCtx.assistantLanguage !== 'other') {
      fallbackResult.assistantLanguage = langCtx.assistantLanguage as 'he' | 'en' | 'ru' | 'ar' | 'fr' | 'es';
    }
    return fallbackResult;
  }
}
