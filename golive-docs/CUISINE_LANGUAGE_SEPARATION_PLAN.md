# Cuisine Language Separation - Implementation Plan

## Executive Summary

**Goal:** Prevent language leakage in TEXTSEARCH mapper and cuisine enforcement by introducing canonical CuisineToken model.

**Status:** ğŸŸ¡ In Progress (3/6 tasks complete)
- âœ… CuisineToken model created
- âœ… Deterministic textQuery generator created
- ğŸŸ¡ Mapper update in progress
- â³ Cuisine enforcer update pending
- â³ Tests pending
- â³ Cache verification pending

## Problem Statement

### Current Issues

1. **Language Leakage in requiredTerms/preferredTerms:**
   ```typescript
   // âŒ BEFORE: Query language affects terms
   query = "××¡×¢×“×•×ª ××™×˜×œ×§×™×•×ª ×‘×ª×œ ××‘×™×‘";  // Hebrew
   requiredTerms = ["××™×˜×œ×§×™×ª", "××™×˜×œ×§×™"];  // Hebrew terms
   
   query = "Italian restaurants in Tel Aviv";  // English
   requiredTerms = ["italian", "Italy"];  // English terms
   
   // Same cuisine, DIFFERENT terms â†’ inconsistent enforcement!
   ```

2. **Language Leakage in textQuery:**
   ```typescript
   // âŒ BEFORE: LLM generates textQuery in query language
   query = "××¡×¢×“×•×ª ××™×˜×œ×§×™×•×ª ×‘×ª×œ ××‘×™×‘";
   textQuery = "××¡×¢×“×•×ª ××™×˜×œ×§×™×•×ª ×ª×œ ××‘×™×‘";  // Hebrew
   
   // But searchLanguage = 'he' (from IL region policy)
   // Should be: "××¡×¢×“×” ××™×˜×œ×§×™×ª ×ª×œ ××‘×™×‘" (deterministic template)
   ```

3. **Cuisine Enforcer Instability:**
   ```typescript
   // âŒ BEFORE: Same places, different query languages â†’ different keepCount
   places = [/* same list */];
   
   // Hebrew query:
   requiredTerms = ["××™×˜×œ×§×™×ª"];
   keepCount = 12;
   
   // English query:
   requiredTerms = ["italian"];
   keepCount = 8;  // Different! LLM interprets differently
   ```

### Root Cause

- No canonical cuisine model
- LLM outputs are language-dependent
- requiredTerms/preferredTerms derived from raw query text
- textQuery generated by LLM in query language

## Solution: Canonical CuisineToken Model

### 1. CuisineToken Model âœ… COMPLETE

**File:** `server/src/services/search/route2/shared/cuisine-tokens.ts`

**Structure:**
```typescript
interface CuisineToken {
  cuisineKey: CuisineKey;  // Canonical: 'italian', 'asian', etc.
  
  searchTerms: {
    he: string[];  // ["××™×˜×œ×§×™×ª", "××™×˜×œ×§×™"]
    en: string[];  // ["italian", "Italy"]
  };
  
  restaurantLabel: {
    he: string;  // "××¡×¢×“×” ××™×˜×œ×§×™×ª"
    en: string;  // "Italian restaurant"
  };
  
  preferredTerms?: {
    he: string[];  // ["×¤×¡×˜×”", "×¤×™×¦×”"]
    en: string[];  // ["pasta", "pizza"]
  };
}
```

**Coverage:** 29 cuisine categories (italian, asian, japanese, chinese, thai, indian, mediterranean, middle_eastern, american, mexican, french, seafood, steakhouse, pizza, sushi, burger, vegan, vegetarian, kosher, dairy, meat, fish, breakfast, cafe, bakery, dessert, fast_food, fine_dining, casual_dining)

**API:**
- `getCuisineSearchTerms(cuisineKey, searchLanguage)` â†’ string[]
- `getCuisinePreferredTerms(cuisineKey, searchLanguage)` â†’ string[]
- `getCuisineRestaurantLabel(cuisineKey, searchLanguage)` â†’ string

### 2. Deterministic TextQuery Generator âœ… COMPLETE

**File:** `server/src/services/search/route2/stages/route-llm/textquery-generator.ts`

**Templates:**
```typescript
// Explicit cuisine + city
textQuery = "{cuisineLabel} {city}";
// Example: "Italian restaurant Tel Aviv" (EN)
// Example: "××¡×¢×“×” ××™×˜×œ×§×™×ª ×ª×œ ××‘×™×‘" (HE)

// Explicit cuisine, no city
textQuery = "{cuisineLabel}";
// Example: "Italian restaurant" (EN)

// Generic + city
textQuery = "{typeLabel} {city}";
// Example: "restaurant Tel Aviv" (EN)

// Generic, no city
textQuery = "{typeLabel}";
// Example: "restaurant" (EN)
```

**Invariants:**
- âœ… Same cuisineKey + city + searchLanguage â†’ identical textQuery
- âœ… textQuery language = searchLanguage (never query language)
- âœ… No user query text in output

### 3. Updated TextSearch Mapper ğŸŸ¡ IN PROGRESS

**File:** `server/src/services/search/route2/stages/route-llm/textsearch.mapper.ts`

**Changes:**

#### A. Updated LLM Schema

**Before:**
```typescript
{
  "textQuery": "string",  // LLM generates
  "requiredTerms": ["string"],  // LLM extracts from query
  "preferredTerms": ["string"]  // LLM extracts from query
}
```

**After:**
```typescript
{
  "textQuery": "string",  // Optional (deprecated)
  "cuisineKey": "italian" | "asian" | ...,  // NEW: Canonical key
  "requiredTerms": [],  // Deprecated (generated from cuisineKey)
  "preferredTerms": []  // Deprecated (generated from cuisineKey)
}
```

#### B. Updated LLM Prompt

**Before:**
```
6) If explicit cuisine:
   - requiredTerms = [cuisine term(s) from query]
   - preferredTerms = [related terms]
```

**After:**
```
6) If explicit cuisine detected:
   - Extract the PRIMARY cuisine category as cuisineKey
   - Valid keys: italian, asian, japanese, chinese, thai, indian, ...
   - Do NOT extract query text - ONLY select the matching key
   - Example: "××¡×¢×“×•×ª ××™×˜×œ×§×™×•×ª" â†’ cuisineKey = "italian"
   - Example: "Asian food" â†’ cuisineKey = "asian"
   - Example: "×¡×•×©×™" â†’ cuisineKey = "sushi"
   
7) If no explicit cuisine or ambiguous:
   - cuisineKey = null
```

#### C. Post-LLM Processing

**New logic:**
```typescript
// 1. Extract cuisineKey from LLM
const llmResponse = await llmProvider.completeJSON(...);
const cuisineKey = llmResponse.data.cuisineKey;

// 2. Generate textQuery deterministically
const textQuery = generateTextQuery({
  cuisineKey,
  cityText: normalizedCityText,
  searchLanguage: languageContext.searchLanguage,
  typeHint: llmResponse.data.typeHint
});

// 3. Generate requiredTerms/preferredTerms from cuisineKey
const requiredTerms = cuisineKey 
  ? getCuisineSearchTerms(cuisineKey, searchLanguage)
  : [];

const preferredTerms = cuisineKey 
  ? getCuisinePreferredTerms(cuisineKey, searchLanguage)
  : [];

// 4. Return mapping
return {
  providerMethod: 'textSearch',
  textQuery,  // Deterministic!
  requiredTerms,  // Stable for same cuisineKey!
  preferredTerms,  // Stable for same cuisineKey!
  cuisineKey,  // NEW: For cache key + enforcement
  strictness: cuisineKey ? 'STRICT' : 'RELAX_IF_EMPTY',
  ...
};
```

### 4. Updated Cuisine Enforcer â³ PENDING

**File:** `server/src/services/search/route2/stages/cuisine-enforcer/cuisine-enforcer.service.ts`

**Changes:**

#### A. Updated Input Interface

**Before:**
```typescript
interface CuisineEnforcerInput {
  requiredTerms: string[];  // Language-dependent
  preferredTerms: string[];  // Language-dependent
  strictness: 'STRICT' | 'RELAX_IF_EMPTY';
  places: PlaceInput[];
}
```

**After:**
```typescript
interface CuisineEnforcerInput {
  cuisineKey: CuisineKey | null;  // NEW: Canonical key
  requiredTerms: string[];  // Generated from cuisineKey (stable)
  preferredTerms: string[];  // Generated from cuisineKey (stable)
  strictness: 'STRICT' | 'RELAX_IF_EMPTY';
  places: PlaceInput[];
  searchLanguage: 'he' | 'en';  // NEW: For logging
}
```

#### B. Updated Logging

**Add observability:**
```typescript
logger.info({
  requestId,
  event: 'cuisine_enforcement_llm_call',
  cuisineKey,  // NEW: Canonical key
  searchLanguage,  // NEW: Which language terms are in
  requiredTermsCount,
  placesCount
}, '[CUISINE_ENFORCER] Enforcing with canonical cuisine key');
```

### 5. Regression Tests â³ PENDING

**File:** `server/src/services/search/route2/__tests__/cuisine-language-separation.test.ts`

**Test Cases:**

#### A. Same Cuisine, Different Query Languages â†’ Same Output

```typescript
describe('Cuisine Language Separation', () => {
  it('Hebrew query "××¡×¢×“×•×ª ××™×˜×œ×§×™×•×ª ×‘×ª×œ ××‘×™×‘" -> cuisineKey=italian', async () => {
    const result = await executeTextSearchMapper({
      query: '××¡×¢×“×•×ª ××™×˜×œ×§×™×•×ª ×‘×ª×œ ××‘×™×‘',
      languageContext: { searchLanguage: 'he', ... }
    });
    
    assert.strictEqual(result.cuisineKey, 'italian');
    assert.strictEqual(result.textQuery, '××¡×¢×“×” ××™×˜×œ×§×™×ª ×ª×œ ××‘×™×‘');
    assert.deepStrictEqual(result.requiredTerms, ['××™×˜×œ×§×™×ª', '××™×˜×œ×§×™']);
  });
  
  it('English query "Italian restaurants in Tel Aviv" -> cuisineKey=italian', async () => {
    const result = await executeTextSearchMapper({
      query: 'Italian restaurants in Tel Aviv',
      languageContext: { searchLanguage: 'he', ... }  // IL region -> HE search
    });
    
    assert.strictEqual(result.cuisineKey, 'italian');
    assert.strictEqual(result.textQuery, '××¡×¢×“×” ××™×˜×œ×§×™×ª ×ª×œ ××‘×™×‘');  // Same as Hebrew query!
    assert.deepStrictEqual(result.requiredTerms, ['××™×˜×œ×§×™×ª', '××™×˜×œ×§×™']);  // Same as Hebrew query!
  });
  
  it('Spanish query "restaurantes italianos en Tel Aviv" -> cuisineKey=italian', async () => {
    const result = await executeTextSearchMapper({
      query: 'restaurantes italianos en Tel Aviv',
      languageContext: { searchLanguage: 'he', ... }
    });
    
    assert.strictEqual(result.cuisineKey, 'italian');
    assert.strictEqual(result.textQuery, '××¡×¢×“×” ××™×˜×œ×§×™×ª ×ª×œ ××‘×™×‘');  // Same as above!
    assert.deepStrictEqual(result.requiredTerms, ['××™×˜×œ×§×™×ª', '××™×˜×œ×§×™']);  // Same as above!
  });
});
```

#### B. Cuisine Enforcer Stability

```typescript
describe('Cuisine Enforcer Stability', () => {
  const places = [/* mock Italian + non-Italian places */];
  
  it('Same cuisineKey + places -> stable keepCount (Hebrew terms)', async () => {
    const result = await executeCuisineEnforcement({
      cuisineKey: 'italian',
      requiredTerms: ['××™×˜×œ×§×™×ª', '××™×˜×œ×§×™'],  // Hebrew
      preferredTerms: ['×¤×¡×˜×”', '×¤×™×¦×”'],
      strictness: 'STRICT',
      places,
      searchLanguage: 'he'
    });
    
    assert.ok(result.keepPlaceIds.length > 0);
    const hebrewKeepCount = result.keepPlaceIds.length;
    
    // Re-run with English terms (same cuisineKey)
    const result2 = await executeCuisineEnforcement({
      cuisineKey: 'italian',
      requiredTerms: ['italian', 'Italy'],  // English
      preferredTerms: ['pasta', 'pizza'],
      strictness: 'STRICT',
      places,
      searchLanguage: 'en'
    });
    
    // Keep count should be similar (Â±1 due to LLM variance, but NOT wildly different)
    const englishKeepCount = result2.keepPlaceIds.length;
    const difference = Math.abs(hebrewKeepCount - englishKeepCount);
    assert.ok(difference <= 2, `Keep counts should be similar: HE=${hebrewKeepCount}, EN=${englishKeepCount}`);
  });
});
```

#### C. Cache Key Stability

```typescript
describe('Cache Key Stability', () => {
  it('Cache key uses cuisineKey + searchLanguage (not query/assistant language)', () => {
    const params1 = {
      cuisineKey: 'italian',
      cityText: 'Tel Aviv',
      searchLanguage: 'he',
      queryLanguage: 'he',  // Hebrew query
      assistantLanguage: 'he'
    };
    
    const params2 = {
      cuisineKey: 'italian',
      cityText: 'Tel Aviv',
      searchLanguage: 'he',
      queryLanguage: 'en',  // English query (different!)
      assistantLanguage: 'en'  // English assistant (different!)
    };
    
    // Cache keys should be IDENTICAL
    const key1 = generateCacheKey(params1);
    const key2 = generateCacheKey(params2);
    assert.strictEqual(key1, key2, 'Cache keys must be identical when cuisineKey + searchLanguage match');
  });
});
```

### 6. Cache Key Verification â³ PENDING

**Files to Check:**
- `server/src/services/search/route2/stages/google-maps/cache-manager.ts`
- `server/src/lib/cache/googleCacheUtils.ts`

**Ensure cache keys include:**
- âœ… cuisineKey (canonical)
- âœ… searchLanguage (policy-based)
- âœ… cityText (normalized)
- âœ… regionCode

**Ensure cache keys EXCLUDE:**
- âŒ queryLanguage (varies with user input)
- âŒ assistantLanguage (varies with LLM confidence)
- âŒ Raw query text
- âŒ requiredTerms/preferredTerms (derived from cuisineKey)

## Behavior Changes

### âœ… Bug Fixes Only

| Scenario | Before (Bug) | After (Fix) |
|----------|--------------|-------------|
| Hebrew query for Italian in Tel Aviv | requiredTerms = ["××™×˜×œ×§×™×ª"] | cuisineKey = "italian" â†’ requiredTerms = ["××™×˜×œ×§×™×ª", "××™×˜×œ×§×™"] (stable) |
| English query for Italian in Tel Aviv | requiredTerms = ["italian"] | cuisineKey = "italian" â†’ requiredTerms = ["××™×˜×œ×§×™×ª", "××™×˜×œ×§×™"] (same as above!) |
| Spanish query for Italian in Tel Aviv | requiredTerms = ["italiano"] | cuisineKey = "italian" â†’ requiredTerms = ["××™×˜×œ×§×™×ª", "××™×˜×œ×§×™"] (same as above!) |
| Cuisine enforcement keepCount | Varies by language | Stable for same cuisineKey |
| Cache hit rate | Poor (language-dependent keys) | Improved (canonical keys) |

### âŒ No Functional Changes

- âœ… Same cuisines detected
- âœ… Same places returned (after enforcement)
- âœ… Same ranking
- âœ… textQuery more consistent (deterministic templates)

## Implementation Status

### Completed âœ…

1. âœ… CuisineToken model (`cuisine-tokens.ts`)
   - 29 cuisine categories
   - Multilingual search terms
   - Restaurant labels for textQuery
   - Preferred terms for relaxation

2. âœ… Deterministic textQuery generator (`textquery-generator.ts`)
   - Template-based generation
   - Uses searchLanguage only
   - Normalizes city text
   - No LLM dependency

3. âœ… Updated schemas (`schemas.ts`, `static-schemas.ts`)
   - Added `cuisineKey` field
   - Marked `textQuery`/`requiredTerms`/`preferredTerms` as generated
   - Updated version to v4

### In Progress ğŸŸ¡

4. ğŸŸ¡ Update textsearch mapper
   - Need to update LLM prompt
   - Need to implement post-LLM processing logic
   - Need to integrate textQuery generator
   - Need to integrate cuisine registry

### Pending â³

5. â³ Update cuisine enforcer
   - Add `cuisineKey` to input interface
   - Update logging for observability
   - Keep backward compatibility

6. â³ Add regression tests
   - Same cuisine, different languages â†’ same cuisineKey
   - Cuisine enforcer stability
   - Cache key stability

7. â³ Verify cache keys
   - Ensure cuisineKey included
   - Ensure queryLanguage/assistantLanguage excluded

## Invariant Verification Checklist

Use this checklist to verify implementation:

### âœ… Invariant 1: cuisineKey is Language-Independent

- [x] CuisineToken model uses canonical keys âœ…
- [x] LLM extracts cuisineKey (not raw terms) â³
- [ ] Same cuisine â†’ same cuisineKey (all languages) â³
- [ ] Test: he/en/es queries â†’ same cuisineKey â³

### âœ… Invariant 2: textQuery Generated in searchLanguage

- [x] TextQuery generator exists âœ…
- [x] Generator uses searchLanguage only âœ…
- [ ] Mapper uses generator (not LLM output) â³
- [ ] Test: Same cuisineKey + city â†’ identical textQuery â³

### âœ… Invariant 3: requiredTerms/preferredTerms from Cuisine Registry

- [x] Cuisine registry has searchTerms âœ…
- [x] getCuisineSearchTerms() function exists âœ…
- [ ] Mapper generates terms from cuisineKey â³
- [ ] Test: Same cuisineKey â†’ identical requiredTerms â³

### âœ… Invariant 4: Cuisine Enforcer Receives Stable Inputs

- [x] Input interface includes cuisineKey â³
- [ ] Enforcer logs cuisineKey â³
- [ ] Test: Same cuisineKey + places â†’ stable keepCount â³

### âœ… Invariant 5: Cache Keys Exclude Query/Assistant Language

- [ ] Cache key includes cuisineKey â³
- [ ] Cache key includes searchLanguage â³
- [ ] Cache key excludes queryLanguage â³
- [ ] Cache key excludes assistantLanguage â³
- [ ] Test: Language change â†’ cache hit â³

## Risk Assessment

**Risk Level:** ğŸŸ¢ Low (Pure refactoring with stable API)

### Mitigations

- âœ… Canonical model defined (CuisineToken)
- âœ… Deterministic generator (no LLM variance)
- âœ… Backward compatible (old fields kept)
- â³ Comprehensive tests needed
- â³ Phased rollout recommended

### Rollback Plan

**If issues found:**
1. Revert mapper changes
2. Keep using LLM-generated requiredTerms
3. No schema/database changes to rollback
4. Cache invalidation not needed (keys backward compatible)

## Next Steps

### Immediate (Complete Current Sprint)

1. âœ… Finish textsearch mapper update
2. â³ Update cuisine enforcer
3. â³ Add regression tests (15-20 tests)
4. â³ Verify cache keys

### Before Staging

1. â³ Code review
2. â³ Linter check
3. â³ All tests passing
4. â³ Documentation complete

### Staging Validation

1. â³ Deploy to staging
2. â³ Test real queries in different languages
3. â³ Monitor cuisineKey extraction accuracy
4. â³ Verify keepCount stability
5. â³ Check cache hit rates

---

**Document Version:** 1.0  
**Last Updated:** 2026-01-31  
**Status:** ğŸŸ¡ In Progress (3/6 complete)  
**Ready for:** Continued implementation
