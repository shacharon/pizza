# KEYED vs FREE_TEXT Mode + Cuisine Enforcement Improvements

## Implementation Summary

This document summarizes the three major refactors implemented to improve the Route2 TEXTSEARCH pipeline:

---

## Prompt 1: KEYED vs FREE_TEXT Mode + Schema Changes

### What Changed

**Schema Updates (`static-schemas.ts` & `schemas.ts`):**

- **REMOVED** `textQuery` from required LLM output fields
- **ADDED** new fields to LLM schema:
  - `mode`: `"KEYED" | "FREE_TEXT"` - determines query construction strategy
  - `cuisineKey`: canonical cuisine identifier (e.g., "italian", "asian")
  - `placeTypeKey`: place type key (optional, for future expansion)
  - `cityText`: extracted city name (required if explicit city mentioned)
- **Schema version**: Updated to `textsearch_v5_keyed_freetext_mode`

**Mapper Prompt Changes (`textsearch.mapper.ts`):**

- LLM now **extracts structured intent** (keys + mode) instead of generating full query sentences
- Prompt instructs LLM to:
  - Use `KEYED` mode when explicit cuisine/city detected
  - Use `FREE_TEXT` mode for generic queries
  - Output ONLY semantic keys, NOT full query sentences
- Version: `textsearch_mapper_v4_keyed_freetext`

**Deterministic Query Builder (`textsearch.mapper.ts`):**
New function `buildProviderQuery()` constructs provider queries based on mode:

1. **KEYED Mode (cuisine + city)**:

   ```typescript
   providerTextQuery = "Italian restaurant in Gedera";
   providerLanguage = "en"; // Always English for structured queries
   ```

2. **KEYED Mode (cuisine only)**:

   ```typescript
   providerTextQuery = "Italian restaurant";
   providerLanguage = "en";
   ```

3. **FREE_TEXT Mode**:
   ```typescript
   providerTextQuery = clean(originalUserQuery); // Trim, collapse spaces
   providerLanguage = queryLanguage; // Preserve original language
   ```

**Benefits:**

- **Deterministic**: Same intent → same query (no LLM variance)
- **Language-independent**: Cuisine keys prevent language leakage
- **Transparent**: Clear separation between semantic extraction (LLM) and query building (deterministic)

---

## Prompt 2: Refactor Google Stage to Use `providerTextQuery`/`providerLanguage`

### What Changed

**Removed Legacy Canonical Query System:**

- Eliminated `canonicalTextQuery` field (was generated by separate LLM call)
- Removed `generateCanonicalQuery()` and `getCachedCanonicalQuery()` usage in mapper
- Removed `canonicalizeTextQuery()` normalization in mapper

**New Provider Fields:**

- `providerTextQuery`: The actual query sent to Google (deterministically built)
- `providerLanguage`: The language sent to Google API (may differ from query language)

**Google Stage Updates (`text-search.handler.ts`):**

- **Added assertions**: Fail fast if old `canonicalTextQuery` field is present
- **Direct usage**: Google stage now uses `mapping.providerTextQuery` and `mapping.providerLanguage` directly
- **Enhanced logging**: All logs show `providerTextQuery` and `providerLanguage` with mode context

**Benefits:**

- **Single source of truth**: Query built once in mapper, used consistently
- **No redundant LLM calls**: Removed extra LLM call for canonical query generation
- **Clearer data flow**: Mapper → Google (no intermediate transformations)
- **Fail-fast validation**: Assertions catch refactor inconsistencies immediately

---

## Prompt 3: Cuisine Enforcement Improvements

### 1. Small-Sample Guard (< 5 results)

**Problem:** Enforcement could wipe all results when Google returned 1-4 places (common in small cities).

**Solution:**

```typescript
if (places.length < 5) {
  logger.info({ reason: "small_sample", countIn: places.length });
  return {
    keepPlaceIds: places.map((p) => p.placeId),
    enforcementSkipped: true,
  };
}
```

**Benefits:**

- **Never reduces to 0**: Protects small result sets
- **Logged transparently**: `enforcementSkipped: true` in logs
- **Preserves user experience**: Shows 1 Italian restaurant instead of 0

### 2. Real Relax Strategy (STRICT → SOFT → Google Rerun)

**Problem:** When STRICT enforcement returned 0 results, system kept empty set (bad UX).

**Solution - Two-stage relaxation in orchestrator:**

**Relax #1: Downgrade STRICT → SOFT**

```typescript
if (enforcementResult.keepPlaceIds.length === 0) {
  // Convert requiredTerms → preferredTerms (SOFT mode)
  const relaxedInput = {
    requiredTerms: [],
    preferredTerms: [...mapping.requiredTerms, ...mapping.preferredTerms],
    strictness: 'RELAX_IF_EMPTY'
  };
  enforcementResult = await executeCuisineEnforcement(relaxedInput, ...);
}
```

**Relax #2: Rerun Google with Broader Query**

```typescript
if (enforcementResult.keepPlaceIds.length === 0 && mapping.cityText) {
  // Build broader query: "restaurants in <city>"
  const broaderMapping = {
    ...mapping,
    providerTextQuery: `restaurants in ${mapping.cityText}`,
    providerLanguage: 'en',
    cuisineKey: null
  };

  const broaderResults = await executeTextSearch(broaderMapping, ctx);
  // Apply SOFT enforcement to broader results
  enforcementResult = await executeCuisineEnforcement({
    ...relaxedInput,
    places: broaderResults
  }, ...);
}
```

**Benefits:**

- **Progressive relaxation**: Try SOFT before rerunning Google
- **Fallback to generic results**: Show "restaurants in city" if no cuisine matches
- **One rerun max**: Relax #2 runs only once (prevents infinite loops)
- **Logged extensively**: Each relax stage logged with strategy and counts

### 3. Enhanced Schema

**Updated Response Schema (`cuisine-enforcer.schema.ts`):**

```typescript
{
  keepPlaceIds: string[];
  relaxApplied: boolean;
  relaxStrategy: 'none' | 'fallback_preferred' | 'drop_required_once' | 'google_rerun_broader';
  enforcementSkipped?: boolean; // New field
}
```

---

## Tests Added

**New Test File:** `cuisine-enforcer-edge-cases.test.ts`

**Test Coverage:**

1. **Small Sample Guard:**

   - Skip enforcement when countIn = 1
   - Skip enforcement when countIn = 4
   - Run enforcement when countIn = 5 (threshold)

2. **Zero Results Scenarios:**

   - Graceful handling (no crash)
   - Metadata annotation when skipped

3. **Relaxation Strategies:**

   - `fallback_preferred` strategy
   - `drop_required_once` strategy

4. **Error Handling:**

   - LLM failure (return all places gracefully)
   - Empty input handling

5. **Integration Scenarios:**
   - "1 Italian result in small city" (real-world use case)
   - "5 generic results, 0 matches" with relaxation trigger

---

## Migration Notes

### Breaking Changes

1. **Schema Change**: `textQuery` no longer required in LLM response
2. **New Required Fields**: `mode`, `providerTextQuery`, `providerLanguage` in mapping
3. **Removed Fields**: `canonicalTextQuery` no longer exists

### Backwards Compatibility

- **Fallback mapping**: When LLM fails, deterministic builder uses same mode-based approach
- **Graceful degradation**: Small sample guard prevents UX regressions
- **Logging**: Extensive logs help debug mode/query issues

### Validation Added

- **Google stage assertion**: Fails fast if `canonicalTextQuery` field present
- **Required field check**: Validates `providerTextQuery` and `providerLanguage` exist
- **Schema validation**: `assertStrictSchema()` runs before OpenAI calls

---

## Key Improvements

### 1. Determinism

- Same intent → same query (no LLM variance in query construction)
- Cuisine keys prevent language leakage
- Predictable behavior for debugging

### 2. Performance

- Removed extra LLM call (canonical query generation)
- Faster pipeline execution
- Reduced costs

### 3. Robustness

- Small sample guard prevents wiping results
- Real relax strategy provides fallback
- Extensive error handling and logging

### 4. Maintainability

- Clear separation: LLM extracts intent, mapper builds query
- Single source of truth for provider fields
- Fail-fast assertions catch refactor issues

---

## Files Changed

### Core Implementation

- `server/src/services/search/route2/stages/route-llm/static-schemas.ts`
- `server/src/services/search/route2/stages/route-llm/schemas.ts`
- `server/src/services/search/route2/stages/route-llm/textsearch.mapper.ts`
- `server/src/services/search/route2/stages/google-maps/text-search.handler.ts`
- `server/src/services/search/route2/stages/cuisine-enforcer/cuisine-enforcer.service.ts`
- `server/src/services/search/route2/stages/cuisine-enforcer/cuisine-enforcer.schema.ts`
- `server/src/services/search/route2/route2.orchestrator.ts`

### Tests Added

- `server/src/services/search/route2/stages/cuisine-enforcer/__tests__/cuisine-enforcer-edge-cases.test.ts`

---

## Testing Recommendations

### 1. Unit Tests

Run the new edge case tests:

```bash
npm test -- cuisine-enforcer-edge-cases
```

### 2. Integration Tests

Test scenarios:

- "מסעדות איטלקיות בגדרה" (Italian restaurants in small city - should keep 1 result)
- "מסעדות טובות" (generic query - should use FREE_TEXT mode)
- "Italian restaurant in Tel Aviv" (KEYED mode with city)
- Queries with 1-4 results (small sample guard should trigger)

### 3. Logs to Monitor

- `mode: "KEYED"` or `mode: "FREE_TEXT"` in mapper logs
- `providerTextQuery` and `providerLanguage` in Google call logs
- `enforcementSkipped: true` when countIn < 5
- `relax_strategy_soft` and `google_rerun_broader` during relaxation

---

## Future Enhancements

1. **Place Type Keys**: Implement `placeTypeKey` field (currently optional/unused)
2. **More Cuisines**: Expand `CUISINE_REGISTRY` with additional cuisine types
3. **Multi-cuisine Queries**: Support "Italian or Japanese" queries
4. **Relax Tuning**: Adjust threshold (currently 5) based on metrics
5. **Caching**: Cache Google rerun results to avoid duplicate API calls

---

## Questions?

For debugging:

- Check logs for `mode`, `providerTextQuery`, `providerLanguage`
- Look for `enforcementSkipped` flag in cuisine enforcement logs
- Monitor `relax_strategy` field for relaxation paths

For issues:

- Validate schema changes are reflected in static-schemas.ts
- Check that Google stage uses `providerTextQuery` (not `textQuery`)
- Ensure cuisine enforcement threshold (5) is appropriate for your use case
